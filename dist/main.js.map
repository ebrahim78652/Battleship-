{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;;AAAqC;AACG;AAC8B;AACtE;AACO;AACP,qBAAqB,qDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAY;AAC9C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAkB;AAC3C,yBAAyB,qEAAkB;AAC3C;AACA,4BAA4B,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAkB;AAC3C,yBAAyB,qEAAkB;AAC3C,4BAA4B,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;;;;;;;;;;;;;;;;ACpE+B;AACe;;AAEvC;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,2DAAW;AACrB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP,mBAAmB,4CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpHO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;ACPA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA,IAAI;;AAEJ,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;;;;;;UCdA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNwC;AACH;AACC;;AAEtC,aAAa,mDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC","sources":["webpack://Battleship/./src/Computer.js","webpack://Battleship/./src/Gameboard.js","webpack://Battleship/./src/Randomgenerators.js","webpack://Battleship/./src/Ship.js","webpack://Battleship/./src/utlityMethods.js","webpack://Battleship/webpack/bootstrap","webpack://Battleship/webpack/runtime/define property getters","webpack://Battleship/webpack/runtime/hasOwnProperty shorthand","webpack://Battleship/webpack/runtime/make namespace object","webpack://Battleship/./src/index.js"],"sourcesContent":["import { Block, Ship } from \"./Ship\";\r\nimport { Gameboard } from \"./Gameboard\";\r\nimport { getRandomInt, getRandomArbitrary } from \"./Randomgenerators\";\r\n\r\nexport function Computer() {\r\n  const _gameboard = Gameboard();\r\n\r\n  function placeShipsRandomly() {\r\n    const SIZE_CARRIER = 5;\r\n    const SIZE_BATTLESHIP = 4;\r\n    const SIZE_CRUISER = 3;\r\n    const SIZE_SUBMARINE = 3;\r\n    const SIZE_DESTROYER = 2;\r\n\r\n    const arrShipSizes = [\r\n      SIZE_CARRIER,\r\n      SIZE_BATTLESHIP,\r\n      SIZE_CRUISER,\r\n      SIZE_SUBMARINE,\r\n      SIZE_DESTROYER,\r\n    ];\r\n\r\n    arrShipSizes.forEach((size) => {\r\n      while (true) {\r\n        const orientationNumber = getRandomInt(2);\r\n        let orientation;\r\n        if (orientationNumber === 0) {\r\n          orientation = \"horizontal\";\r\n        } else {\r\n          orientation = \"vertical\";\r\n        }\r\n\r\n        // now the x and y coordinates\r\n        if (orientation === \"horizontal\") {\r\n          const xCoord = getRandomArbitrary(0, 100 - size);\r\n          const yCoord = getRandomArbitrary(0, 100);\r\n\r\n          const shipToAdd = Ship(size, [xCoord, yCoord], \"horizontal\");\r\n          const resultOfAdding = _gameboard.addShip(shipToAdd);\r\n          if (resultOfAdding) {\r\n            break;\r\n          }\r\n        }\r\n        if (orientation === \"vertical\") {\r\n          const xCoord = getRandomArbitrary(0, 100);\r\n          const yCoord = getRandomArbitrary(0, 100 - size);\r\n          const shipToAdd = Ship(size, [xCoord, yCoord], \"vertical\");\r\n          const resultOfAdding = _gameboard.addShip(shipToAdd);\r\n          if (resultOfAdding) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  function checkGameOver() {\r\n    if (_gameboard.isAllShipsSunk()) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function hitCoordinate([x_coord, y_coord]) {\r\n    _gameboard.hitCoordinate([x_coord, y_coord]);\r\n  }\r\n\r\n  return { placeShipsRandomly, hitCoordinate, checkGameOver };\r\n}\r\n","import { Block } from \"./Ship\";\nimport { arraysEqual } from \"./utlityMethods\";\n\nexport function Gameboard() {\n  const _missedBlocks = [];\n  const _ships = [];\n  let isLastHitSuccessful = false;\n  const lastSuccessfulHitCoordinates = [0, 0];\n\n  function addShip(ship) {\n    // add validations here before ading every ship;\n    const blocksOfShip = ship.getBlocks();\n    const lengthOfShip = blocksOfShip.length;\n    const startingBlock = blocksOfShip[0];\n    const [xFirstBlock, yFirstBlock] = startingBlock.getCoordinates();\n    const orientationShip = ship.getOrientation();\n\n    // ship should not overflow the board\n    if (\n      (orientationShip === \"horizontal\" && xFirstBlock + lengthOfShip < 99) ||\n      (orientationShip === \"vertical\" && yFirstBlock + lengthOfShip < 99)\n    ) {\n      // check if ship has any block in common with the already placed Ships\n      let blockIntersectionOccuring = false;\n      _ships.some((shipElement) => {\n        shipElement.getBlocks().some((block) => {\n          blocksOfShip.some((toBePlacedBlock) => {\n            if (\n              arraysEqual(\n                block.getCoordinates(),\n                toBePlacedBlock.getCoordinates()\n              )\n            ) {\n              blockIntersectionOccuring = true;\n              return true;\n            }\n          });\n        });\n      });\n\n      if (blockIntersectionOccuring) {\n        return false;\n      }\n      // if both of the above conditions are satisfied, then add the ship to the array\n      _ships.push(ship);\n      return true;\n    }\n\n    // if reached here, the the ship is either horizontal and\n    // overflowing OR vertical and overflowing\n    return false;\n  }\n\n  function hitCoordinate([x_coord, y_coord]) {\n    const blockAlreadyChosen = _missedBlocks.filter((element) => {\n      if (arraysEqual(element.getCoordinates(), [x_coord, y_coord])) {\n        return true;\n      }\n    });\n\n    if (blockAlreadyChosen.length === 0) {\n      _ships.forEach((ship) => {\n        const _blocks = ship.getBlocks();\n        _blocks.forEach((block) => {\n          if (\n            arraysEqual(block.getCoordinates(), [x_coord, y_coord]) &&\n            !block.isHit()\n          ) {\n            block.getsHit();\n            isLastHitSuccessful = true;\n            lastSuccessfulHitCoordinates[0] = x_coord;\n            lastSuccessfulHitCoordinates[1] = y_coord;\n            return true;\n          }\n          isLastHitSuccessful = false;\n          return false;\n        });\n      });\n\n      const miss = Block();\n      miss.setCoordinates(x_coord, y_coord);\n      _missedBlocks.push(miss);\n      isLastHitSuccessful = false;\n      return true;\n    }\n    isLastHitSuccessful = false;\n    return false;\n  }\n\n  function isAllShipsSunk() {\n    let allSunk = true;\n    _ships.forEach((ship) => {\n      if (!ship.isSunk()) {\n        allSunk = false;\n        return true;\n      }\n    });\n\n    return allSunk;\n  }\n\n  function getIsLastHitSuccessful() {\n    return isLastHitSuccessful;\n  }\n\n  function getLastSuccessfulCoordinates() {\n    return lastSuccessfulHitCoordinates;\n  }\n\n  return {\n    hitCoordinate,\n    addShip,\n    isAllShipsSunk,\n    getIsLastHitSuccessful,\n    getLastSuccessfulCoordinates,\n  };\n}\n","export function getRandomInt(max) {\r\n  const c = Math.floor(Math.random() * max);\r\n  return c;\r\n}\r\n\r\nexport function getRandomArbitrary(min, max) {\r\n  return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n","// factory fucntion for a ship\n\nexport function Ship(\n  numBlocks,\n  [init_x_coordinate, init_y_coordinate],\n  orientation\n) {\n  const _blocks = new Array(numBlocks);\n  const _orientation = orientation;\n\n  // the blocks right now dont have any coordinates.\n  /* for (let i = 0; i < numBlocks; i++) {\n    _blocks[i] = Block();\n  } */\n\n  for (let i = 0; i < numBlocks; i++) {\n    const block = Block();\n    if (orientation === \"horizontal\") {\n      block.setCoordinates(init_x_coordinate, init_y_coordinate);\n      init_x_coordinate += 1;\n    }\n    if (orientation === \"vertical\") {\n      block.setCoordinates(init_x_coordinate, init_y_coordinate);\n      init_y_coordinate += 1;\n    }\n\n    _blocks[i] = block;\n  }\n\n  function hitBlock(blockNum) {\n    _blocks[blockNum].getsHit();\n  }\n\n  function getBlocks() {\n    return _blocks;\n  }\n\n  function isSunk() {\n    let sunk = true;\n    _blocks.forEach((block) => {\n      if (block.isHit() === false) {\n        sunk = false;\n        return sunk;\n      }\n    });\n    return sunk;\n  }\n\n  function getOrientation() {\n    return _orientation;\n  }\n\n  return { hitBlock, getBlocks, isSunk, getOrientation };\n}\n\nexport function Block() {\n  let _hit = false;\n  let x_coord = 0;\n  let y_coord = 0;\n\n  function getsHit() {\n    _hit = true;\n  }\n\n  function isHit() {\n    return _hit;\n  }\n\n  function setCoordinates(x, y) {\n    x_coord = x;\n    y_coord = y;\n  }\n\n  function getCoordinates() {\n    return [x_coord, y_coord];\n  }\n\n  return {\n    isHit,\n    getsHit,\n    setCoordinates,\n    getCoordinates,\n  };\n}\n","export function arraysEqual(a, b) {\r\n  if (a === b) return true;\r\n  if (a == null || b == null) return false;\r\n  if (a.length !== b.length) return false;\r\n\r\n  // If you don't care about the order of the elements inside\r\n  // the array, you should sort both arrays here.\r\n  // Please note that calling sort on an array will modify that array.\r\n  // you might want to clone your array first.\r\n\r\n  for (let i = 0; i < a.length; ++i) {\r\n    if (a[i] !== b[i]) return false;\r\n  }\r\n  return true;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Gameboard } from \"./Gameboard\";\nimport { Block, Ship } from \"./Ship\";\nimport { Computer } from \"./Computer\";\n\nconst comp = Computer();\ncomp.placeShipsRandomly();\ncomp.gameboard._ships.forEach((ship) => {\n  console.log(ship.getOrientation());\n  ship.getBlocks().forEach((block) => {\n    console.log(block.getCoordinates());\n  });\n});\n"],"names":[],"sourceRoot":""}